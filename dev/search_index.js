var documenterSearchIndex = {"docs":
[{"location":"pn_expressions/#Binding-energy","page":"PN expressions","title":"Binding energy","text":"","category":"section"},{"location":"pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_dynamics/binding_energy.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"pn_expressions/#Flux","page":"PN expressions","title":"Flux","text":"","category":"section"},{"location":"pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_dynamics/flux.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"pn_expressions/#Tidal-heating","page":"PN expressions","title":"Tidal heating","text":"","category":"section"},{"location":"pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_dynamics/tidal_heating.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"pn_expressions/#Precession","page":"PN expressions","title":"Precession","text":"","category":"section"},{"location":"pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_dynamics/precession.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"termination_criteria/#Termination-criteria-for-inspiral-evolution","page":"Termination criteria","title":"Termination criteria for inspiral evolution","text":"","category":"section"},{"location":"termination_criteria/","page":"Termination criteria","title":"Termination criteria","text":"These are the termination criteria used by default in the inspiral function.","category":"page"},{"location":"termination_criteria/","page":"Termination criteria","title":"Termination criteria","text":"CurrentModule = PostNewtonian","category":"page"},{"location":"termination_criteria/","page":"Termination criteria","title":"Termination criteria","text":"termination_forwards\ntermination_backwards\ndtmin_terminator\nnonfinite_terminator","category":"page"},{"location":"termination_criteria/#PostNewtonian.termination_forwards","page":"Termination criteria","title":"PostNewtonian.termination_forwards","text":"termination_forwards(vₑ, [quiet])\n\nConstruct termination criteria of solving PN evolution forwards in time\n\nThese criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at vₑ.\n\nThe optional quiet argument will silence informational messages about reaching the target value of vₑ if set to true, but warnings will still be issued when terminating for other reasons.  If you want to quiet warnings also, you can do something like this:\n\nusing Logging\nwith_logger(SimpleLogger(Logging.Error)) do\n    <your code goes here>\nend\n\n\n\n\n\n","category":"function"},{"location":"termination_criteria/#PostNewtonian.termination_backwards","page":"Termination criteria","title":"PostNewtonian.termination_backwards","text":"termination_backwards(v₁, [quiet])\n\nConstruct termination criteria of solving PN evolution backwards in time\n\nThese criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at v₁.\n\nThe optional quiet argument will silence informational messages about reaching the target value of v₁ if set to true, but warnings will still be issued when terminating for other reasons.  If you want to quiet warnings also, you can do something like this:\n\nusing Logging\nwith_logger(SimpleLogger(Logging.Error)) do\n    <your code goes here>\nend\n\n\n\n\n\n","category":"function"},{"location":"termination_criteria/#PostNewtonian.dtmin_terminator","page":"Termination criteria","title":"PostNewtonian.dtmin_terminator","text":"dtmin_terminator(T)\n\nConstruct termination criterion to terminate when dt drops below √eps(T).\n\nPass force_dtmin=true to solve when using this callback.  Otherwise, the time-step size may decrease too much within a single time step, so that the integrator itself will quit before reaching this callback, leading to a less graceful exit.\n\n\n\n\n\n","category":"function"},{"location":"termination_criteria/#PostNewtonian.nonfinite_terminator","page":"Termination criteria","title":"PostNewtonian.nonfinite_terminator","text":"nonfinite_terminator()\n\nConstruct termination criterion to terminate when any NaN or Inf is found in the data after an integration step.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Mass-parameter-conversions","page":"Utilities","title":"Mass-parameter conversions","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"masses.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#PostNewtonian.q-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.q","text":"q(M₁, M₂)\nmass_ratio(M₁, M₂)\n\nCompute mass ratio M₁M₂.\n\nNote that we do not restrict to M₁  M₂ or vice versa; if you prefer that q always be greater than or equal to 1 (or vice versa), you are responsible for ensuring that.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.δ-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.δ","text":"δ(M₁, M₂)\nmass_difference_ratio(M₁, M₂)\n\nCompute mass-difference ratio (M₁-M₂)(M₁+M₂).\n\nNote that we do not restrict to M₁  M₂ or vice versa; if you prefer that δ always be positive (or always negative), you are responsible for ensuring that.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.μ-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.μ","text":"μ(M₁, M₂)\nreduced_mass(M₁, M₂)\n\nCompute the reduced mass (M₁ M₂)(M₁+M₂).\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.ν-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.ν","text":"ν(M₁, M₂)\nreduced_mass_ratio(M₁, M₂)\n\nCompute the reduced mass ratio (M₁ M₂)(M₁+M₂)^2.\n\nNote that the denominator is squared, unlike in the reduced mass μ.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.ℳ-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.ℳ","text":"ℳ(M₁, M₂)\nchirp_mass(M₁, M₂)\n\nCompute the chirp mass ℳ, which determines the leading-order orbital evolution of a binary system due to energy loss by gravitational-wave emission.\n\nThe chirp mass is defined as\n\n  mathcalM = frac(M₁ M₂)^35 (M₁ + M₂)^15\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Spin-parameter-conversions","page":"Utilities","title":"Spin-parameter conversions","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"spins.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#PostNewtonian.S-NTuple{4, Any}","page":"Utilities","title":"PostNewtonian.S","text":"S(M₁, M₂, χ⃗₁, χ⃗₂)\n\nTotal spin vector S₁+S₂.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.Σ-NTuple{4, Any}","page":"Utilities","title":"PostNewtonian.Σ","text":"Σ(M₁, M₂, χ⃗₁, χ⃗₂)\n\nDifferential spin vector M(a₂-a₁).\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.χₐ-NTuple{4, Any}","page":"Utilities","title":"PostNewtonian.χₐ","text":"χₐ(M₁, M₂, χ⃗₁, χ⃗₂)\n\nAntisymmetric spin vector (χ₁-χ₂)2.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.χₛ-NTuple{4, Any}","page":"Utilities","title":"PostNewtonian.χₛ","text":"χₛ(M₁, M₂, χ⃗₁, χ⃗₂)\n\nSymmetric spin vector (χ₁+χ₂)2.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.χ⃗-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.χ⃗","text":"χ⃗(S⃗, M)\n\nNormalized spin vector SM².\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Orbital-elements","page":"Utilities","title":"Orbital elements","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"n̂\nλ̂\nℓ̂\nv\nΩ","category":"page"},{"location":"utilities/#PostNewtonian.n̂","page":"Utilities","title":"PostNewtonian.n̂","text":"n̂(R)\nn_hat(R)\n\nThe unit vector pointing from object 2 to object 1, when the frame is given by the rotor R.  This is equal to\n\nn(R) = R x R\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PostNewtonian.λ̂","page":"Utilities","title":"PostNewtonian.λ̂","text":"λ̂(R)\nlambda_hat(R)\n\nThe unit vector pointing in the direction of the instantaneous velocity of object 1, when the frame is given by the rotor R.  This is equal to\n\nλ(R) = R y R\n\nThis also completes the right-handed triple of (ℓ n λ).\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PostNewtonian.ℓ̂","page":"Utilities","title":"PostNewtonian.ℓ̂","text":"ℓ̂(R)\nell_hat(R)\n\nThe unit vector pointing along the direction of orbital angular velocity, when the frame is given by the rotor R.  This is equal to\n\nℓ(R) = R z R\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PostNewtonian.v","page":"Utilities","title":"PostNewtonian.v","text":"v(;Ω, M=1)\n\nPost-Newtonian velocity parameter.\n\nThe parameter Ω is the orbital angular frequency, and must be passed as a keyword argument — as in v(Ω=0.1).  The parameter M is the total mass of the binary.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PostNewtonian.Ω","page":"Utilities","title":"PostNewtonian.Ω","text":"Ω(;v, M=1)\nOmega(;v, M=1)\n\nOrbital angular frequency.\n\nThe parameter v is the PN velocity parameter, and must be passed as a keyword argument — as in Ω(v=0.1).  The parameter M is the total mass of the binary.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ODE-solutions","page":"Utilities","title":"ODE solutions","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"combine_solutions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#PostNewtonian.combine_solutions-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.combine_solutions","text":"combine_solutions(sol₋, sol₊)\n\nCombine ODESolutions\n\nThis function is internal to this package.  It is not entirely general, but allows us to combine the backwards- and forwards-in-time solutions of the PN inspiral ODE equations into a single ODESolution object that should behave just as if it were the result of solve.  In particular, indexing, interpolation, and iterations should behave exactly as described in the DifferentialEquations docs.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Irrational-constants","page":"Utilities","title":"Irrational constants","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"These quantities are constants that appear in PN expressions, so they are not exported, but can be used by importing them explicitly or by using the fully qualified names.  They are defined here as Irrationals.  This means that Julia can convert them to float types as necessary.  Unfortunately, by default Julia converts to Float64.  For example, BigFloat(2ζ3) will be a BigFloat, but will only have the precision of a Float64, because 2ζ3 is converted first.  To get full precision, you'll need to do things like 2BigFloat(ζ3).","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nFilter = t -> typeof(t) !== Irrational{:apery}\nPages   = [\"constants.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#PostNewtonian.log2","page":"Utilities","title":"PostNewtonian.log2","text":"log2\n\nThe natural logarithm of 2.  This is OEIS sequence A002162.\n\njulia> PostNewtonian.log2\nlog2 = 0.6931471805599...\n\njulia> exp(PostNewtonian.log2)\n2.0\n\njulia> exp(big(PostNewtonian.log2))\n2.0\n\n\n\n\n\n","category":"constant"},{"location":"utilities/#PostNewtonian.log3","page":"Utilities","title":"PostNewtonian.log3","text":"log3\n\nThe natural logarithm of 3.  This is OEIS sequence A002391.\n\njulia> PostNewtonian.log3\nlog3 = 1.0986122886681...\n\njulia> exp(PostNewtonian.log3)\n3.0000000000000004\n\njulia> exp(big(PostNewtonian.log3))\n3.0\n\n\n\n\n\n","category":"constant"},{"location":"utilities/#PostNewtonian.log3halves","page":"Utilities","title":"PostNewtonian.log3halves","text":"log3halves\n\nThe natural logarithm of 3//2.  This is OEIS sequence A016578.\n\njulia> PostNewtonian.log3halves\nlog3halves = 0.4054651081081...\n\njulia> exp(PostNewtonian.log3halves)\n1.5\n\njulia> exp(big(PostNewtonian.log3halves))\n1.5\n\n\n\n\n\n","category":"constant"},{"location":"utilities/#PostNewtonian.log5","page":"Utilities","title":"PostNewtonian.log5","text":"log5\n\nThe natural logarithm of 5.  This is OEIS sequence A016628.\n\njulia> PostNewtonian.log5\nlog5 = 1.6094379124341...\n\njulia> exp(PostNewtonian.log5)\n4.999999999999999\n\njulia> exp(big(PostNewtonian.log5))\n5.0\n\n\n\n\n\n","category":"constant"},{"location":"utilities/#PostNewtonian.log5halves","page":"Utilities","title":"PostNewtonian.log5halves","text":"log5halves\n\nThe natural logarithm of 5//2.  This is OEIS sequence A016579.\n\njulia> PostNewtonian.log5halves\nlog5halves = 0.9162907318741...\n\njulia> exp(PostNewtonian.log5halves)\n2.5\n\njulia> exp(big(PostNewtonian.log5halves))\n2.5\n\n\n\n\n\n","category":"constant"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"PostNewtonian.ζ3","category":"page"},{"location":"utilities/#PostNewtonian.ζ3","page":"Utilities","title":"PostNewtonian.ζ3","text":"ζ3\napery\n\nApéry's constant is defined as ζ(3), where ζ is the Riemann zeta function.  This is OEIS sequence A002117.\n\njulia> PostNewtonian.apery\napery = 1.2020569031595...\n\njulia> PostNewtonian.ζ3\napery = 1.2020569031595...\n\njulia> sum((1:10_000_000).^-3) - PostNewtonian.apery\n-4.6629367034256575e-15\n\n\n\n\n\n","category":"constant"},{"location":"python/#Using-this-package-from-Python","page":"Calling from Python","title":"Using this package from Python","text":"","category":"section"},{"location":"python/","page":"Calling from Python","title":"Calling from Python","text":"While not quite as natural as calling Python code from Julia, it is very easy to call Julia code from Python.  The process is essentially the same as using any other Python package, other than installing Julia itself and any dependencies within Julia that you may need (both of which are much easier than similar tasks in Python).","category":"page"},{"location":"python/","page":"Calling from Python","title":"Calling from Python","text":"Note that the Julia packages are installed uniquely to your python environment — preferably a conda env.  For example, if you use two different conda envs to call into Julia, you'll need to install the Julia packages for each env.  This has the great advantage of allowing you to use different packages or versions in each of the different environments.","category":"page"},{"location":"python/","page":"Calling from Python","title":"Calling from Python","text":"Install Julia\nThe juliaup installer has pretty broad support from some of the main Julia developers, and seems likely to be the main installation method in the not-too-distant future.\nOtherwise, the official method is to just download a binary from the official download page.\nMake sure that the julia executable is on your PATH.\nOptionally, create a conda[1] env just for this task\nconda create -n julia_pn python numpy matplotlib\nconda activate julia_pn\nAdd whatever other packages you use to that first line.\nInstall juliacall and install PostNewtonian\npython -m pip install git+https://github.com/cjdoris/PythonCall.jl.git@1126b561\npython -c 'from juliacall import Main as jl; jl.seval(\"\"\"using Pkg; Pkg.add(\"PostNewtonian\")\"\"\")'\n(Yes, you should use pip from inside a conda env.)  This will take a few minutes to compile all the necessary packages in Julia.\nTest the installation\nStart up a python session and run something like this:\n# Any python imports you need go here\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Start the Julia session\nfrom juliacall import Main as jl\n\n# Import `PostNewtonian` in the Julia session\njl.seval(\"using PostNewtonian\")\n\n# Declare some parameters\ndelta = 0.0\nchi1 = np.array([0.1, 0.2, 0.3])\nchi2 = np.array([-0.2, 0.1, -0.3])\nOmega_i = 0.01\n\n# Call into Julia to run some function\nw = jl.GWFrames.PNWaveform(\"TaylorT1\", delta, chi1, chi2, Omega_i)\n\n# Plot the magnitudes of all the modes as functions of time\nplt.semilogy(w.t, np.abs(w.data))\nThe last line above uses the GWFrames.PNWaveform function from this package, which is meant to emulate the original syntax from the GWFrames package.  The resulting w will have various fields, like t, data, and frame, similar to those attached to WaveformModes objects in the scri and sxs packages.","category":"page"},{"location":"python/","page":"Calling from Python","title":"Calling from Python","text":"In general, you can now call any Julia function by prepending jl. to the call you would make in Julia.  As a fallback, you can evaluate actual Julia code in the Julia session using jl.seval(\"<Julia code goes here>\").  This returns whatever the Julia code would return.  A simple example is x = jl.seval(\"1+2\").  See the documentation for juliacall here for more details.","category":"page"},{"location":"python/","page":"Calling from Python","title":"Calling from Python","text":"Typically, the main stumbling block is converting Python lists to Julia Vectors when calling Julia functions.  Frequently, Julia code will have difficulty if you try to pass a Python list, because lists do not have any specific type that Julia can understand.  Instead, you should always convert a list to a numpy array with np.asarray.  It is still possible that numpy will not understand the type of the list, and you'll still get an error from Julia; in this case you need to figure out the dtype to tell numpy about..","category":"page"},{"location":"python/","page":"Calling from Python","title":"Calling from Python","text":"Fortunately, conversion back to Python objects is more automatic.  In particular, if Julia returns a Vector, Matrix, or more generally shaped Array, you can usually just use that quantity in calls to Python functions. If you really need a numpy array, the returned object will have a .to_numpy() method.","category":"page"},{"location":"python/","page":"Calling from Python","title":"Calling from Python","text":"Of course, it is much simpler to call Python code from Julia, so if you find yourself using a lot of Julia code, you may want to consider flipping your approach.","category":"page"},{"location":"python/","page":"Calling from Python","title":"Calling from Python","text":"[1]: As general advice, you should conda install -y mamba in your \"base\"   conda env, and then just use the command mamba wherever you would have   used conda; mamba is a complete drop-in replacement, but is much   faster because it's written in C instead of python.  For example, mamba   create -n julia_pn python numpy matplotlib will typically run faster   than the command given here.  This becomes a huge advantage when the env   has lots of dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PostNewtonian","category":"page"},{"location":"#PostNewtonian","page":"Home","title":"PostNewtonian","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package computes orbital dynamics of and waveforms from binary black-hole systems, in the post-Newtonian approximation. Currently, there is no support for eccentric systems, but general precessing quasicircular systems are supported.","category":"page"},{"location":"#Integrating-inspiral-dynamics","page":"Home","title":"Integrating inspiral dynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"inspiral","category":"page"},{"location":"#PostNewtonian.inspiral","page":"Home","title":"PostNewtonian.inspiral","text":"inspiral(M₁, M₂, χ⃗₁, χ⃗₂, Ωᵢ; kwargs...)\n\nIntegrate the orbital dynamics of an inspiraling non-eccentric compact binary.\n\nRequired arguments\n\nM₁: Initial mass of black hole 1\nM₂: Initial mass of black hole 2\nχ⃗₁: Initial dimensionless spin of black hole 1, S⃗₁/M₁²\nχ⃗₂: Initial dimensionless spin of black hole 2, S⃗₂/M₂²\nΩᵢ: Initial orbital angular velocity\n\nThese parameters all describe the \"initial\" conditions.  See below for an explanation of the different meanings of \"initial\" and \"first\" in this context. Note that the masses change in time as a result of tidal heating — though the changes are quite small throughout most of the inspiral.  The spins change direction due to precession, but also change in magnitude due to tidal heating. Therefore, the values passed here are only precisely as given precisely at the moment of the initial data corresponding to the frequency Ωᵢ.\n\nKeyword arguments\n\nΩ₁=Ωᵢ: First angular velocity in output data (see next section).\nΩₑ=1: Final angular velocity at which to stop ODE integration.\nRᵢ=Rotor(true): Initial orientation of binary.\nPNSys=TaylorT1: Currently the only possibility.\nPNOrder=7//2: Not actually used currently.\ncheck_up_down_instability=true: Warn if the \"up-down instability\" (see below) is likely to affect this system.\ntime_stepper=AutoVern9(Rodas5()): Choice of solver in OrdinaryDiffEq to integrate ODE.\nabstol=eps(T)^(11//16): Absolute tolerance of ODE solver, where T is the common type to which all the positional arguments are promoted.  This is the tolerance on local error estimates, not necessarily the global error.\nreltol=eps(T)^(11//16): Relative tolerance of ODE solver.  (As above.)\ntermination_criteria_forwards=nothing: Callbacks to use for forwards-in-time evolution.  See below for discussion of the default value.\ntermination_criteria_backwards=nothing: Callbacks to use for backwards-in-time evolution.  See below for discussion of the default value.\nforce_dtmin=true: If dt decreases below the integrator's own minimum, and this is false, the integrator will immediately raise an error, before the termination criteria have the chance to exit gracefully.  Note that a true value here is critical if the dtmin_terminator callback is to have any effect.\nquiet=false: If set to true, informational messages about successful terminations of the ODE integrations (which occur when the target v is reached in either direction) will be silenced.  Warnings will still be issued when terminating for other reasons; if you wish to silence them too, you should do something like\nusing Logging\nwith_logger(SimpleLogger(Logging.Error)) do\n    <your code goes here>\nend\nintegrate_orbital_phase=false: If set to true, integrate the orbital phase Φ along with the rest of the system.  Note that this may slow the system down because the absolute value of Φ may grow to very large values, so that the abstol will strain to keep its evolution far more accurate than is really needed.  If this is a problem, you can loosen abstol and/or pass vectors of separate tolerances for each variable in the ODE system (see below).\n\nAll remaining keyword arguments are passed to the solve function of DiffEqBase.  See that function's documentation for details, including useful keyword arguments.  The most likely important ones are\n\nsaveat: Denotes specific times to save the solution at, during the solving phase.\ndt: Sets the initial stepsize. Defaults to an automatic choice if the method is adaptive.\ndtmax: Maximum dt for adaptive timestepping.\ndtmin: Minimum dt for adaptive timestepping.\n\nNote that if you want the solution to be output with specifically spaced time steps, you don't want dt, which is just the initial suggestion for adaptive systems; you want to set saveat to the desired spacing.  [The saveat argument could be a vector of specific times at which to save, but because we don't know when the PN evolution ends, this probably isn't useful.]\n\nAlso note that callback can be used, and is combined with the callbacks generated by the termination_criteria_* arguments above.  See the documentation for more details, but note that if you want to make your own callbacks, you will need to add OrdinaryDiffEq to your project — or possibly even DifferentialEquations for some of the fancier built-in callbacks.\n\nODE system\n\nThe evolved variables, in order, are\n\nM₁: Mass of black hole 1\nM₂: Mass of black hole 2\nχ⃗₁ˣ: x component of dimensionless spin of black hole 1\nχ⃗₁ʸ: y component...\nχ⃗₁ᶻ: z component...\nχ⃗₂ˣ: x component of dimensionless spin of black hole 2\nχ⃗₂ʸ: y component...\nχ⃗₂ᶻ: z component...\nRʷ: Scalar component of frame rotor\nRˣ: x component...\nRʸ: y component...\nRᶻ: z component...\nv: PN \"velocity\" parameter related to the total mass M and orbital angular velocity Ω by v = (M Ω)^13\nΦ: Orbital phase given by integrating Ω (optional; only appears if integrate_orbital_phase is true)\n\nThe masses and spin magnitudes evolve according to tidal_heating. The spin directions evolve according to Ω⃗ᵪ₁ and Ω⃗ᵪ₂.  The frame rotor R is given by integrating the angular velocity as described in Boyle (2016), while the angular velocity itself is given by Ω⃗ₚ.  And finally, the PN parameter v evolves according to something like\n\ndotv = - fracmathcalF + dotM_1 + dotM_2 mathcalE\n\nwhere 𝓕 is the flux of gravitational-wave energy out of the system and 𝓔′ is the derivative of the binding energy with respect to v. For \"TaylorT1\", the right-hand side of this equation is evaluated as given; for \"TaylorT4\", the right-hand side is first expanded as a Taylor series in v and then truncated at some desired order; for \"TaylorT5\", the inverse of the right-hand side is expanded as a Taylor series in v, truncated at some desired order, and then inverted to obtain an expression in terms of v.\n\nReturned solution\n\nThe returned quantity is an ODESolution object, which has various features for extracting and interpolating the data.  We'll call this object sol.\n\nnote: Note\nThe solution comes with data at the time points the ODE integrator happened to step to.  However, it also comes with dense output (unless you manually turn it off when calling inspiral).  This means that you can interpolate the solution to any other set of time points you want simply by calling it as sol(t) for some vector of time points t.  The quantity returned by that will have the following features, just like the original solution.  Note that if you only want some of the data you can provide the optional keyword argument idxs to specify which of the elements described below you want to interpolate.  For example, if you only want to interpolate the values of M₁ and M₂, you can use sol(t, idxs=[1,2]).\n\nThe field sol.t is the set of time points at which the solution is given.  To access the ith variable at time step j, use sol[i, j].[1] You can also use colons.  For example, sol[:, j] is a vector of all the data at time step j, and sol[i, :] is a vector of the ith variable at all times.\n\n[1]: Here, the ith variable just refers to which number it has in the list   of evolved variables in the ODE system, as described under \"ODE system\".\n\nInitial frequency vs. first frequency vs. end frequency\n\nNote the distinction between Ωᵢ (with subscript i) and Ω₁ (with subscript 1).  The first, Ωᵢ, represents the angular velocity of the initial condition from which the ODE integrator will begin; the second, Ω₁, represents the target angular velocity of the first element of the output data. That is, the ODE integration will run forwards in time from Ωᵢ to the merger, and then come back to Ωᵢ and run backwards in time to Ω₁.  The output data will stitch these two together to be one continuous (forwards-in-time) data series.\n\nFor example, if you are trying to match to a numerical relativity (NR) simulation, you can read the masses and spins off of the NR data when the system is orbiting at angular velocity Ωᵢ.  Integrating the post-Newtonian (PN) solution forwards in time from this point will allow you to compare the PN and NR waveforms.  However, you may want to know what the waveform was at earlier times than are present in the NR data.  For this, you also have to integrate backwards in time.  We parametrise the point to which you integrate backwards with Ω₁.  In either case, element 1 of the output solution will have frequency Ω₁ — though by default it is equal to Ωᵢ.\n\nSimilarly, the optional argument Ωₑ=1 is the frequency of the end element of the solution — that is Julia's notation for the last element.  Note that this is automatically reduced if necessary so that the corresponding PN parameter v is no greater than 1, which may be the case whenever the total mass is greater than 1.\n\nUp-down instability\n\nBe aware that the up-down instability (where the more massive black hole has spin aligned with the orbital angular velocity, and the less massive has spin anti-aligned) can cause systems with nearly zero precession at the initial time to evolve into a highly precessing system either at earlier or later times.  This is a real physical result, rather than a numerical issue.  If you want to simulate a truly non-precessing system, you should explicitly set the in-place components of spin to precisely 0.  By default, we check for this condition, and will issue a warning if it is likely to be encountered for systems with low initial precession.  The function used to compute the unstable region is up_down_instability.\n\nTime-stepper algorithms\n\nTsit5() is a good default choice for time stepper when using Float64 with medium-low tolerance.  If stiffness seems to be impacting the results, AutoTsit5(Rosenbrock23()) will automatically switch when stiffness occurs. For tighter tolerances, especially when using Double64s, Vern9() or AutoVern9(Rodas5()) are good choices.  For very loose tolerances, as when using Float32s, it might be better to use OwrenZen3().\n\nTermination criteria\n\nThe termination criteria are vital to efficiency of the integration and correctness of the solution.  The default values for forwards- and backwards-in-time evolution, respectively, are\n\nCallbackSet(\n    termination_forwards(v(Ω=Ωₑ, M=M₁+M₂)),\n    dtmin_terminator(T),\n    nonfinite_terminator()\n)\n\nand\n\nCallbackSet(\n    termination_backwards(v(Ω=Ω₁, M=M₁+M₂)),\n    dtmin_terminator(T),\n    nonfinite_terminator()\n)\n\nwhere T is the common float type of the input arguments.  If any additional termination criteria are needed, they could be added as additional elements of the CallbackSets.  See the callback documentation for details.\n\n\n\n\n\n","category":"function"},{"location":"#Computing-mode-weights-from-the-inspiral-data","page":"Home","title":"Computing mode weights from the inspiral data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"h!","category":"page"},{"location":"#PostNewtonian.h!","page":"Home","title":"PostNewtonian.h!","text":"h!(h, u; ℓmin=0)\nh!(h, M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v; ℓmin=0)\nmode_weights!(h, u; ℓmin=0)\nmode_weights!(h, M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v; ℓmin=0)\n\nCompute mode weights of gravitational waves emitted by pn system, modifying h in place.\n\nThese modes are computed in the \"co-orbital\" frame, in which the larger object lies on the positive x axis, the smaller lies on the negative x axis, and the instantaneous angular velocity is in the positive z direction.\n\nThe modes are stored in h in order of increasing ℓ and increasing m, with m iterating fastest, all the way up to the highest available mode, (88).\n\nBecause gravitational waves have spin weight -2, the (ℓm)=(00), (1-1), (10), and (11) modes are always 0.  By default, we assume that these modes are nonetheless included in h.  If that is not the case, set ℓmin to the smallest ℓ value that should be present in the output data — ℓmin=2 being the most reasonable alternative.\n\nAll non-spinning terms are taken from Blanchet (2014).  The 1PN spin-orbit term is from Eq. (3.22d) of Kidder (1995).  The 1.5PN spin-orbit term is from Eq. (3.22f) of Kidder (1995) and Eq. (F15b) of Will and Wiseman (1996).  The 2PN spin-orbit term is from Eq. (4.13) of Buonanno, Faye, Hinderer (2013), while the 2PN spin-spin term is from Eq. (4.15) of that reference.\n\n\n\n\n\n","category":"function"},{"location":"#Detecting-up-down-instability","page":"Home","title":"Detecting up-down instability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"up_down_instability","category":"page"},{"location":"#PostNewtonian.up_down_instability","page":"Home","title":"PostNewtonian.up_down_instability","text":"up_down_instability(u)\nup_down_instability(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nCompute the range of frequencies over which the system is unstable to increasing precession.\n\nThe returned value is a pair of dimensionless frequencies giving the lower and upper frequencies between which we can expect instability.  If there is no instability expected, the returned pair is just (1,1).\n\nFor compact binaries in which the spins are either aligned or anti-aligned with the orbital angular velocity, we do not expect any precession effects — simply by symmetry.  However, if the spin of the higher-mass object is aligned with the orbital angular velocity and the spin of the lower-mass object is anti-aligned, the binary is unstable to precession — meaning that any minuscule misalignment can grow rapidly into significant precession.  This was first reported by Gerosa et al. (2015), and the range over which the system is unstable is given by Eq. (2) of that reference. We use the lowest-order approximation to convert binary separation to frequency.  The result is also \"clamped\" between 0 and 1, because sometimes the PN approximations involved break down and return unphysical values.\n\n\n\n\n\n","category":"function"},{"location":"#Index-of-all-functions","page":"Home","title":"Index of all functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"gwframes/#GWFrames-compatibility-layer","page":"GWFrames","title":"GWFrames compatibility layer","text":"","category":"section"},{"location":"gwframes/","page":"GWFrames","title":"GWFrames","text":"GWFrames is an old python package that was too hard to upgrade to python 3, and therefore became impossible to maintain.  Many of its capabilities have been superseded by the scri and sxs packages, but not the post-Newtonian capabilities.  This package now supersedes the latter.  For convenience, the PostNewtonian.GWFrames submodule provides a simple function to mimic the arguments used with the original GWFrames package to obtain a PN waveform (with a couple extra arguments).  We won't bother to provide a return type that can fully mimic the object returned by the original GWFrames package, though it should be similar to the ones used by scri and sxs.","category":"page"},{"location":"gwframes/","page":"GWFrames","title":"GWFrames","text":"Modules = [PostNewtonian.GWFrames]\nPages   = [\"gwframes.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"gwframes/#PostNewtonian.GWFrames.PNWaveform","page":"GWFrames","title":"PostNewtonian.GWFrames.PNWaveform","text":"PNWaveform(Approximant, delta, chi1_i, chi2_i, Omega_orb_i; kwargs...)\n\nCompute a PN waveform, with the same call signature as GWFrames.PNWaveform\n\nThis is essentially a compatibility layer for the corresponding function in the original GWFrames Python package, with two additional optional arguments: dt and quiet (see below).  Also, this function accepts optional arguments either as positional arguments (which the original GWFrames requires) or as keyword arguments.\n\nwarning: Warning\nWe do not expect the result of this function to be identical to the result from the GWFrames Python package.  In particular, this package uses more general expressions for the tidal-heating terms, fixes an error in the 2PN quadratic-spin terms for the waveform modes, uses a more accurate method to compute the number of steps per orbit (by default), and uses more accurate (and efficient) ODE integration.\n\nThe Julia interface is more detailed, flexible, and efficient than the simple GWFrames interface that this function emulates.  In particular, inspiral takes essentially all the same arguments that DifferentialEquations.solve takes, and returns a solution that provides dense output and more details about the ODE solution itself.  For example, one reason this function is more efficient than GWFrames is that we can use dense output to solve with fewer timesteps, while accurately and efficiently interpolating to the requested timesteps.  While inspiral solves for the dynamics, h! provides the actual mode weights, which are also returned by this function.\n\nRequired arguments\n\nApproximant: Currently, only \"TaylorT1\" is supported.\ndelta: Fractional mass difference (M₁-M₂)(M₁+M₂)\nchi1_i: Normalized spin vector S₁M₁²\nchi2_i: Normalized spin vector S₂M₂²\nOmega_orb_i: Orbital angular frequency at initial instant\n\nOptional arguments\n\nAs mentioned above, the following may be given either as positional arguments in this order (though any number of them may be omitted from the end), or as keyword arguments.\n\nOmega_orb_0=Omega_orb_i: Orbital angular frequency at first instant found in data.  If this is less than Omega_orb_i, the system is integrated backwards in time from the latter value to this value.\nR_frame_i=Rotor(1): Initial orientation of the frame.\nMinStepsPerOrbit=32: Number of time steps in the output data per orbit. Because the waveform modes go as high as m=8, this number should be at least 16 to avoid Nyquist aliasing in those modes.  Note that this value may be overridden by dt (see below).\nPNWaveformModeOrder=3.5: Maximum PN order of terms in the waveform formulas.  Currently, only 3.5 is supported.\nPNOrbitalEvolutionOrder=4.0: Maximum PN order of terms in the orbital-evolution formulas.  Currently, only 4.0 is supported.\ndt=0: Uniform time step size of the output.  If this is not a strictly positive number, MinStepsPerOrbit will be used instead.\nquiet=true: If false, show informational messages about the reasons for terminating the ODE integration.  In either case, warnings will still be issued if terminating for bad or suspicious reasons.  See the documentation of inspiral for an example of how to filter warnings also.\n\nReturned values\n\nThis function returns a NamedTuple with the following keys:\n\nt: The vector of time steps at which the data are evaluated.  The time t=0 corresponds to the initial values that are arguments to this function.\ndata: Matrix of complex values of the mode weights.  The shape is length(t) x 77.  The first dimension enumerates the values at each instant of time.  The second dimension enumerates the modes, starting with (2-2), then (2-1), up to (22), followed by (3-3), and so on up to (88).  This is the opposite ordering as results from GWFrames, but the same as the ordering used by the sxs and scri packages.  However, also note that certain conversions between Julia and Python may transpose matrices, because Julia is Fortran-ordered by default, whereas numpy is C-ordered.  It is best to check the shape manually to be sure which dimension is which.\nframe: Matrix of shape length(t) x 4 representing the frame-orientation quaternion as a function of time t.\nM1, M2: Vectors of the respective masses as functions of time t. Note that only at the time corresponding to Omega_orb_i will the total mass be precisely 1.  Generally, tidal heating will lead to time-dependent masses.\nchi1, chi2: Matrices of shape length(t) x 3 representing the spins as functions of time t.\nv: PN velocity parameter as a function of time t.\nPhi: Orbital phase as a function of time t.\n\nBecause this is a NamedTuple, the fields can be accessed much like the fields of a WaveformModes object in the scri or sxs Python packages — as in w.t and w.data, where w is the object returned by this function.\n\n\n\n\n\n","category":"function"}]
}
