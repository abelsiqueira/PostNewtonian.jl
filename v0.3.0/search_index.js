var documenterSearchIndex = {"docs":
[{"location":"pn_expressions/#Binding-energy","page":"PN Expressions","title":"Binding energy","text":"","category":"section"},{"location":"pn_expressions/","page":"PN Expressions","title":"PN Expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_dynamics/binding_energy.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"pn_expressions/#PostNewtonian.𝓔-NTuple{6, Any}","page":"PN Expressions","title":"PostNewtonian.𝓔","text":"𝓔(u)\n𝓔(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\nbinding_energy(u)\nbinding_energy(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nCompute the binding energy of a compact binary.\n\nNote that this may not be as useful as its derivative, 𝓔′, which is used as part of the right-hand side for orbital evolutions.\n\nThe nonspinning orbital binding energy is known through 4pN.  The expressions through 3.5pN here come from Eq. (233) of Blanchet (2014).\n\nThe 4pN term from Eq. (5.2d) of Jaranowski and Schäfer is known exactly, now that the ν-linear piece is given as Eq. (32) of Bini and Damour (2013a).  The remaining terms are not known exactly, but Bini and Damour (2013b) have derived some terms, though there is incomplete information, which are noted as the constants in the following cell.  Note that, though the notation is confusing, Bini and Damour claim they did not calculate the coefficient they call a_6^ln 1; but it seems to be given in their Eq. (64).\n\nThe spin-squared terms (by which I mean both spin-spin and spin-orbit squared terms) in the energy are known only at 2pN order (from Kidder (1995) and Will and Wiseman (1996)).  They are most conveniently given in Eq. (C4) of Arun et al.\n\nThe spin-orbit terms in the energy are now complete to 4.0pN (the last term is zero).  These terms come from Eq. (4.6) of Bohé et al. (2012):\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#PostNewtonian.𝓔NS-NTuple{15, Any}","page":"PN Expressions","title":"PostNewtonian.𝓔NS","text":"𝓔NS(u, λ₁, λ₂)\n𝓔NS(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v, λ₁, λ₂)\nbinding_energy_NS(u, λ₁, λ₂)\nbinding_energy_NS(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v, λ₁, λ₂)\n\nCompute tidal NS contribution to the gravitational binding energy\n\nThe tidal-coupling terms come in to the energy at relative 5pN order, and are known to 6pN order.  These terms come from Eq. (2.11) of Vines et al. (2011).  Note their unusual convention for mass ratios, where χ₁ = m₁m in their notation; in particular, χ is not a spin parameter.  Also note that λ = λ₂ v^10(m₁+m₂)^5, and we need to add the coupling terms again with 1  2. Finally, note the normalization difference, where a different overall factor is used, leading to a sign difference.\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#PostNewtonian.𝓔′-NTuple{13, Any}","page":"PN Expressions","title":"PostNewtonian.𝓔′","text":"𝓔′(u)\n𝓔′(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\nbinding_energy_deriv(u)\nbinding_energy_deriv(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nCompute the derivative with respect to v of the binding energy of a compact binary.\n\nThis is computed symbolically from 𝓔; see that function for details.\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#Flux","page":"PN Expressions","title":"Flux","text":"","category":"section"},{"location":"pn_expressions/","page":"PN Expressions","title":"PN Expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_dynamics/flux.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"pn_expressions/#PostNewtonian.𝓕-NTuple{13, Any}","page":"PN Expressions","title":"PostNewtonian.𝓕","text":"𝓕(u)\n𝓕(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\ngw_energy_flux(u)\ngw_energy_flux(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nCompute the gravitational-wave energy flux to infinity\n\nThe nonspinning flux terms are complete to 3.5pN order.  These terms are given by Eq. (314) of Blanchet (2014).\n\nThe spin-squared terms (by which I mean both spin-spin and spin-orbit squared terms) in the flux are known only at 2pN order (from Kidder (1995) and Will and Wiseman (1996)).  They are most conveniently given in Eq. (C10) of Arun et al. (2008)\n\nThe spin-orbit terms in the flux are now known to 4.0pN.  These terms come from Eq. (4.9) of Marsat et al. (2013)\n\nBeyond 3.5pN, terms other than the 4.0pN spin-orbit are only known in the extreme-mass-ratio limit.  These terms are given in Appendix A of Fujita (2012).  He computed them up to 22pN. That seems like overkill, so we'll just go up to 6pN.\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#PostNewtonian.𝓕NS-NTuple{15, Any}","page":"PN Expressions","title":"PostNewtonian.𝓕NS","text":"𝓕NS(u, λ₁, λ₂)\n𝓕NS(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v, λ₁, λ₂)\ngw_energy_flux_NS(u, λ₁, λ₂)\ngw_energy_flux_NS(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v, λ₁, λ₂)\n\nCompute tidal NS contribution to the gravitational-wave energy flux to infinity\n\nFor systems with matter, the tidal-coupling terms come in at relative 5pN order, and are known partially at 6pN order.  These terms come from Eq. (3.6) of Vines et al. (2011). Note their unusual convention for mass ratios, where χ₁ = m₁m in their notation; in particular, χ is not a spin parameter.  Also note that λ = λ₂ v^10(m₁+m₂)^5, and we need to add the coupling terms again with 1  2.  Finally, note the normalization difference, where a different overall factor is used, leading to a sign difference.\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#Tidal-heating","page":"PN Expressions","title":"Tidal heating","text":"","category":"section"},{"location":"pn_expressions/","page":"PN Expressions","title":"PN Expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_dynamics/tidal_heating.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"pn_expressions/#PostNewtonian.tidal_heating-NTuple{13, Any}","page":"PN Expressions","title":"PostNewtonian.tidal_heating","text":"tidal_heating(u)\ntidal_heating(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nCompute the rate of energy and angular-momentum absorption into each black hole in a binary.\n\nThe returned quantity is a tuple (Ṡ₁, Ṁ₁, Ṡ₂, Ṁ₂), representing the corresponding rates of change of spin (magnitude) and mass on black hole 1 and black hole 2.  These apply to general — possibly precessing — non-eccentric binaries.  This collection of terms comes from Alvi (2001).  It probably wouldn't be too hard to extend Alvi's analysis to eccentric systems.\n\nNote that the validity of the result depends not only on the PN parameter v, but also on that angles of the spins relative to the separation vector n: the smaller the angle, the lower the v at which the approximations should be expected to break down.\n\nSee also\n\nTagoshi and Sasaki (1994)\nPoisson and Sasaki (1995)\nTagoshi et al. (1997)\nChatziioannou et al. (2012)\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#Precession","page":"PN Expressions","title":"Precession","text":"","category":"section"},{"location":"pn_expressions/","page":"PN Expressions","title":"PN Expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_dynamics/precession.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"pn_expressions/#PostNewtonian.aₗ-NTuple{13, Any}","page":"PN Expressions","title":"PostNewtonian.aₗ","text":"aₗ(u)\naₗ(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nEq. (4.4) of Bohé et al. (2013).  This term contributes to 𝛡.\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#PostNewtonian.Ω⃗ᵪ-NTuple{6, Any}","page":"PN Expressions","title":"PostNewtonian.Ω⃗ᵪ","text":"Ω⃗ᵪ(Mⱼ, Mₖ, χ⃗ⱼ, χ⃗ₖ, R)\n\nCompute the angular velocity of precession of spin vector χ⃗ⱼ.\n\nIn the approximation that the spin magnitude is constant, the time derivative of χⱼ is due to its rotation alone, and is given by Ωᵪ  χⱼ.\n\nNote that this function is called by Ω⃗ᵪ₁ and Ω⃗ᵪ₂ with the appropriate parameters; you probably want to use those instead of this one.\n\nThe spin-spin term is given by Eq. (2.4) of Kidder (1995); the spin-orbit terms by Eq. (4.5) of Bohé et al. (2013); and the quadrupole-monopole term by Eq. (2.7) Racine (2008).\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#PostNewtonian.Ω⃗ᵪ₁-NTuple{13, Any}","page":"PN Expressions","title":"PostNewtonian.Ω⃗ᵪ₁","text":"Ω⃗ᵪ₁(u)\nΩ⃗ᵪ₁(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nCompute the angular velocity of precession of χ⃗₁\n\nIn the approximation that the spin magnitude is constant, the time derivative of χ₁ is due to its rotation alone, and is given by Ωᵪ₁  χ₁.\n\nNote that this function simply calls Ω⃗ᵪ with the appropriate parameters.\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#PostNewtonian.Ω⃗ᵪ₂-NTuple{13, Any}","page":"PN Expressions","title":"PostNewtonian.Ω⃗ᵪ₂","text":"Ω⃗ᵪ₂(u)\nΩ⃗ᵪ₂(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nCompute the angular velocity of precession of χ⃗₂\n\nIn the approximation that the spin magnitude is constant, the time derivative of χ₂ is due to its rotation alone, and is given by Ωᵪ₂  χ₂.\n\nNote that this function simply calls Ω⃗ᵪ with the appropriate parameters.\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#PostNewtonian.Ω⃗ₚ-NTuple{13, Any}","page":"PN Expressions","title":"PostNewtonian.Ω⃗ₚ","text":"Ω⃗ₚ(u)\nΩ⃗ₚ(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nCompute the angular velocity of orbital precession.\n\nThis is the angular velocity of the orbital angular velocity direction unit vector ℓ; the time derivative of that unit vector is Ωₚ  ℓ.\n\nAt the moment, this is computed solely by expressions from Bohé et al. (2013).  See 𝛡 for details.\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#PostNewtonian.γ-NTuple{13, Any}","page":"PN Expressions","title":"PostNewtonian.γ","text":"γ(u)\nγ(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nEq. (4.3) of Bohé et al. (2013).  This term contributes to 𝛡.\n\nNote that there is a 3PN term of -22νln(rr₀)3 that is simply ignored here.\n\n\n\n\n\n","category":"method"},{"location":"pn_expressions/#PostNewtonian.𝛡-NTuple{13, Any}","page":"PN Expressions","title":"PostNewtonian.𝛡","text":"𝛡(u)\n𝛡(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nCompute the angular velocity of orbital precession according to Bohé et al.\n\nAs Bohé et al. (2013) explain above their Eq. (4.1), the orbital precession is given by the time derivative of the orbital axis: 𝓵̇ = 𝛡 × 𝓵, where the angular velocity is along the separation vector 𝓷, so that 𝛡 = ϖ 𝓷.  And in turn, they define aₗ ≔ r ω ϖ, where r is the separation and ω is the orbital angular frequency.  Then, they define the PN parameter γ≔M/r and we have Mω = v³ so that ϖ = γ aₗ / v³.  The parameters γ and aₗ are given by Eqs. (4.3) and (4.4), and given here by the functions γ and aₗ.\n\n\n\n\n\n","category":"method"},{"location":"termination_criteria/#Termination-criteria-for-inspiral-evolution","page":"Termination criteria","title":"Termination criteria for inspiral evolution","text":"","category":"section"},{"location":"termination_criteria/","page":"Termination criteria","title":"Termination criteria","text":"These are the termination criteria used by default in the inspiral function.","category":"page"},{"location":"termination_criteria/","page":"Termination criteria","title":"Termination criteria","text":"CurrentModule = PostNewtonian","category":"page"},{"location":"termination_criteria/","page":"Termination criteria","title":"Termination criteria","text":"termination_forwards\ntermination_backwards\ndtmin_terminator\nnonfinite_terminator","category":"page"},{"location":"termination_criteria/#PostNewtonian.termination_forwards","page":"Termination criteria","title":"PostNewtonian.termination_forwards","text":"termination_forwards(vₑ, [quiet])\n\nConstruct termination criteria of solving PN evolution forwards in time\n\nThese criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at vₑ.\n\nThe optional quiet argument will silence informational messages about reaching the target value of vₑ if set to true, but warnings will still be issued when terminating for other reasons.  If you want to quiet warnings also, you can do something like this:\n\nusing Logging\nwith_logger(SimpleLogger(Logging.Error)) do\n    <your code goes here>\nend\n\n\n\n\n\n","category":"function"},{"location":"termination_criteria/#PostNewtonian.termination_backwards","page":"Termination criteria","title":"PostNewtonian.termination_backwards","text":"termination_backwards(v₁, [quiet])\n\nConstruct termination criteria of solving PN evolution backwards in time\n\nThese criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at v₁.\n\nThe optional quiet argument will silence informational messages about reaching the target value of v₁ if set to true, but warnings will still be issued when terminating for other reasons.  If you want to quiet warnings also, you can do something like this:\n\nusing Logging\nwith_logger(SimpleLogger(Logging.Error)) do\n    <your code goes here>\nend\n\n\n\n\n\n","category":"function"},{"location":"termination_criteria/#PostNewtonian.dtmin_terminator","page":"Termination criteria","title":"PostNewtonian.dtmin_terminator","text":"dtmin_terminator(T)\n\nConstruct termination criterion to terminate when dt drops below √eps(T).\n\nPass force_dtmin=true to solve when using this callback.  Otherwise, the time-step size may decrease too much within a single time step, so that the integrator itself will quit before reaching this callback, leading to a less graceful exit.\n\n\n\n\n\n","category":"function"},{"location":"termination_criteria/#PostNewtonian.nonfinite_terminator","page":"Termination criteria","title":"PostNewtonian.nonfinite_terminator","text":"nonfinite_terminator()\n\nConstruct termination criterion to terminate when any NaN or Inf is found in the data after an integration step.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Mass-parameter-conversions","page":"Utilities","title":"Mass-parameter conversions","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"masses.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#PostNewtonian.q-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.q","text":"q(M₁, M₂)\nmass_ratio(M₁, M₂)\n\nCompute mass ratio M₁M₂.\n\nNote that we do not restrict to M₁  M₂ or vice versa; if you prefer that q always be greater than or equal to 1 (or vice versa), you are responsible for ensuring that.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.δ-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.δ","text":"δ(M₁, M₂)\nmass_difference_ratio(M₁, M₂)\n\nCompute mass-difference ratio (M₁-M₂)(M₁+M₂).\n\nNote that we do not restrict to M₁  M₂ or vice versa; if you prefer that δ always be positive (or always negative), you are responsible for ensuring that.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.μ-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.μ","text":"μ(M₁, M₂)\nreduced_mass(M₁, M₂)\n\nCompute the reduced mass (M₁ M₂)(M₁+M₂).\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.ν-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.ν","text":"ν(M₁, M₂)\nreduced_mass_ratio(M₁, M₂)\n\nCompute the reduced mass ratio (M₁ M₂)(M₁+M₂)^2.\n\nNote that the denominator is squared, unlike in the reduced mass μ.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.ℳ-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.ℳ","text":"ℳ(M₁, M₂)\nchirp_mass(M₁, M₂)\n\nCompute the chirp mass ℳ, which determines the leading-order orbital evolution of a binary system due to energy loss by gravitational-wave emission.\n\nThe chirp mass is defined as\n\n  mathcalM = frac(M₁ M₂)^35 (M₁ + M₂)^15\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Spin-parameter-conversions","page":"Utilities","title":"Spin-parameter conversions","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"spins.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#PostNewtonian.S-NTuple{4, Any}","page":"Utilities","title":"PostNewtonian.S","text":"S(M₁, M₂, χ⃗₁, χ⃗₂)\n\nTotal spin vector S₁+S₂.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.Σ-NTuple{4, Any}","page":"Utilities","title":"PostNewtonian.Σ","text":"Σ(M₁, M₂, χ⃗₁, χ⃗₂)\n\nDifferential spin vector M(a₂-a₁).\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.χₐ-NTuple{4, Any}","page":"Utilities","title":"PostNewtonian.χₐ","text":"χₐ(M₁, M₂, χ⃗₁, χ⃗₂)\n\nAntisymmetric spin vector (χ₁-χ₂)2.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.χₛ-NTuple{4, Any}","page":"Utilities","title":"PostNewtonian.χₛ","text":"χₛ(M₁, M₂, χ⃗₁, χ⃗₂)\n\nSymmetric spin vector (χ₁+χ₂)2.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#PostNewtonian.χ⃗-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.χ⃗","text":"χ⃗(S⃗, M)\n\nNormalized spin vector SM².\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Orbital-elements","page":"Utilities","title":"Orbital elements","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"n̂\nλ̂\nℓ̂\nv\nΩ","category":"page"},{"location":"utilities/#PostNewtonian.n̂","page":"Utilities","title":"PostNewtonian.n̂","text":"n̂(R)\nn_hat(R)\n\nThe unit vector pointing from object 2 to object 1, when the frame is given by the rotor R.  This is equal to\n\nn(R) = R x R\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PostNewtonian.λ̂","page":"Utilities","title":"PostNewtonian.λ̂","text":"λ̂(R)\nlambda_hat(R)\n\nThe unit vector pointing in the direction of the instantaneous velocity of object 1, when the frame is given by the rotor R.  This is equal to\n\nλ(R) = R y R\n\nThis also completes the right-handed triple of (ℓ n λ).\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PostNewtonian.ℓ̂","page":"Utilities","title":"PostNewtonian.ℓ̂","text":"ℓ̂(R)\nell_hat(R)\n\nThe unit vector pointing along the direction of orbital angular velocity, when the frame is given by the rotor R.  This is equal to\n\nℓ(R) = R z R\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PostNewtonian.v","page":"Utilities","title":"PostNewtonian.v","text":"v(;Ω, M=1)\n\nPost-Newtonian velocity parameter.\n\nThe parameter Ω is the orbital angular frequency, and must be passed as a keyword argument — as in v(Ω=0.1).  The parameter M is the total mass of the binary.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PostNewtonian.Ω","page":"Utilities","title":"PostNewtonian.Ω","text":"Ω(;v, M=1)\nOmega(;v, M=1)\n\nOrbital angular frequency.\n\nThe parameter v is the PN velocity parameter, and must be passed as a keyword argument — as in Ω(v=0.1).  The parameter M is the total mass of the binary.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ODE-solutions","page":"Utilities","title":"ODE solutions","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"combine_solutions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#PostNewtonian.combine_solutions-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.combine_solutions","text":"combine_solutions(sol₋, sol₊)\n\nCombine ODESolutions\n\nThis function is internal to this package.  It is not entirely general, but allows us to combine the backwards- and forwards-in-time solutions of the PN inspiral ODE equations into a single ODESolution object that should behave just as if it were the result of solve.  In particular, indexing, interpolation, and iterations should behave exactly as described in the DifferentialEquations docs.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Irrational-constants","page":"Utilities","title":"Irrational constants","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"These quantities are constants that appear in PN expressions, so they are not exported, but can be used by importing them explicitly or by using the fully qualified names.  They are defined here as Irrationals.  This means that Julia can convert them to float types as necessary.  Unfortunately, by default Julia converts to Float64.  For example, BigFloat(2ζ3) will be a BigFloat, but will only have the precision of a Float64, because 2ζ3 is converted first.  To get full precision, you'll need to do things like 2BigFloat(ζ3).","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nFilter = t -> typeof(t) !== Irrational{:apery}\nPages   = [\"constants.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"utilities/#PostNewtonian.log2","page":"Utilities","title":"PostNewtonian.log2","text":"log2\n\nThe natural logarithm of 2.  This is OEIS sequence A002162.\n\njulia> PostNewtonian.log2\nlog2 = 0.6931471805599...\n\njulia> exp(PostNewtonian.log2)\n2.0\n\njulia> exp(big(PostNewtonian.log2))\n2.0\n\n\n\n\n\n","category":"constant"},{"location":"utilities/#PostNewtonian.log3","page":"Utilities","title":"PostNewtonian.log3","text":"log3\n\nThe natural logarithm of 3.  This is OEIS sequence A002391.\n\njulia> PostNewtonian.log3\nlog3 = 1.0986122886681...\n\njulia> exp(PostNewtonian.log3)\n3.0000000000000004\n\njulia> exp(big(PostNewtonian.log3))\n3.0\n\n\n\n\n\n","category":"constant"},{"location":"utilities/#PostNewtonian.log3halves","page":"Utilities","title":"PostNewtonian.log3halves","text":"log3halves\n\nThe natural logarithm of 3//2.  This is OEIS sequence A016578.\n\njulia> PostNewtonian.log3halves\nlog3halves = 0.4054651081081...\n\njulia> exp(PostNewtonian.log3halves)\n1.5\n\njulia> exp(big(PostNewtonian.log3halves))\n1.5\n\n\n\n\n\n","category":"constant"},{"location":"utilities/#PostNewtonian.log5","page":"Utilities","title":"PostNewtonian.log5","text":"log5\n\nThe natural logarithm of 5.  This is OEIS sequence A016628.\n\njulia> PostNewtonian.log5\nlog5 = 1.6094379124341...\n\njulia> exp(PostNewtonian.log5)\n4.999999999999999\n\njulia> exp(big(PostNewtonian.log5))\n5.0\n\n\n\n\n\n","category":"constant"},{"location":"utilities/#PostNewtonian.log5halves","page":"Utilities","title":"PostNewtonian.log5halves","text":"log5halves\n\nThe natural logarithm of 5//2.  This is OEIS sequence A016579.\n\njulia> PostNewtonian.log5halves\nlog5halves = 0.9162907318741...\n\njulia> exp(PostNewtonian.log5halves)\n2.5\n\njulia> exp(big(PostNewtonian.log5halves))\n2.5\n\n\n\n\n\n","category":"constant"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"PostNewtonian.ζ3","category":"page"},{"location":"utilities/#PostNewtonian.ζ3","page":"Utilities","title":"PostNewtonian.ζ3","text":"ζ3\napery\n\nApéry's constant is defined as ζ(3), where ζ is the Riemann zeta function.  This is OEIS sequence A002117.\n\njulia> PostNewtonian.apery\napery = 1.2020569031595...\n\njulia> PostNewtonian.ζ3\napery = 1.2020569031595...\n\njulia> sum((1:10_000_000).^-3) - PostNewtonian.apery\n-4.6629367034256575e-15\n\n\n\n\n\n","category":"constant"},{"location":"python/#Using-this-package-from-python","page":"Python","title":"Using this package from python","text":"","category":"section"},{"location":"python/","page":"Python","title":"Python","text":"Install Julia\nThe juliaup installer has pretty broad support from some of the main Julia developers, and seems likely to be the main installation method in the not-too-distant future.\nOtherwise, the official method is to just download a binary from the official download page.\nMake sure that the julia binary is on your PATH.\nCreate a conda[1] env just for this task\nconda create -n julia_pn python numpy matplotlib\nconda activate julia_pn\nAdd whatever other packages you use to that first line.\nInstall juliacall and build PostNewtonian\npython -m pip install juliacall\npython -c 'from juliacall import Main as jl; jl.seval(\"\"\"using Pkg; Pkg.add(\"PostNewtonian\")\"\"\")'\nThis will take a few minutes to compile all the necessary packages.\nTest the installation.  Start up a python session and run something like this:\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom juliacall import Main as jl, convert as jlconvert\n\nVectorF64 = jl.seval(\"Vector{Float64}\")\njl.seval(\"using PostNewtonian\")\ndelta = 0.0\nchi1 = jlconvert(VectorF64, [0.1, 0.2, 0.3])\nchi2 = jlconvert(VectorF64, [-0.2, 0.1, -0.3])\nOmega_i = 0.01\nw = jl.GWFrames.PNWaveform(\"TaylorT1\", delta, chi1, chi2, Omega_i)\nThe resulting w will have various fields, like t, data, and frame, similar to those attached to WaveformModes objects in the scri and sxs packages.","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"The last line above uses the PNWaveform function from this package, which is meant to emulate the original syntax from the GWFrames package.","category":"page"},{"location":"python/","page":"Python","title":"Python","text":"[1]: In general, it's better to conda install -y mamba in your \"base\" conda   env, and then just use mamba wherever you would have used conda;   mamba is a complete drop-in replacement, but is much faster because   it's written in C instead of python.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PostNewtonian","category":"page"},{"location":"#PostNewtonian","page":"Home","title":"PostNewtonian","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package computes orbital dynamics of and waveforms from binary black-hole systems, in the post-Newtonian approximation. Currently, there is no support for eccentric systems, but general precessing quasicircular systems are supported.","category":"page"},{"location":"#Integrating-inspiral-dynamics","page":"Home","title":"Integrating inspiral dynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"inspiral","category":"page"},{"location":"#PostNewtonian.inspiral","page":"Home","title":"PostNewtonian.inspiral","text":"inspiral(M₁, M₂, χ⃗₁, χ⃗₂, Ωᵢ; kwargs...)\n\nIntegrate the orbital dynamics of an inspiraling non-eccentric compact binary.\n\nKeyword arguments\n\nΩ₁=Ωᵢ: First angular velocity in output data (see next section).\nΩₑ=1: Final angular velocity at which to stop ODE integration.\nRᵢ=Rotor(true): Initial orientation of binary.\nPNSys=TaylorT1: Currently the only possibility.\nPNOrder=7//2: Not actually used currently.\ncheck_up_down_instability=true: Warn if the \"up-down instability\" (see below) is likely to affect this system.\ntime_stepper=AutoVern9(Rodas5()): Choice of solver in OrdinaryDiffEq to integrate ODE.\nabstol=eps(T)^(11//16): Absolute tolerance of ODE solver, where T is the common type to which all the positional arguments are promoted.  This is the tolerance on local error estimates, not necessarily the global error.\nreltol=eps(T)^(11//16): Relative tolerance of ODE solver.  (As above.)\ntermination_criteria_forwards=nothing: Callbacks to use for forwards-in-time evolution.  See below for discussion of the default value.\ntermination_criteria_backwards=nothing: Callbacks to use for backwards-in-time evolution.  See below for discussion of the default value.\nforce_dtmin=true: If dt decreases below the integrator's own minimum, and this is false, the integrator will immediately raise an error, before the termination criteria have the chance to exit gracefully.  Note that a true value here is critical if the dtmin_terminator callback is to have any effect.\nquiet=false: If set to true, informational messages about successful terminations of the ODE integrations (which occur when the target v is reached in either direction) will be silenced.  Warnings will still be issued when terminating for other reasons; if you wish to silence them too, you should do something like\nusing Logging\nwith_logger(SimpleLogger(Logging.Error)) do\n    <your code goes here>\nend\n\nAll remaining keyword arguments are passed to the solve function of DiffEqBase.  See that function's documentation for details, including useful keyword arguments.  The most likely important ones are\n\nsaveat: Denotes specific times to save the solution at, during the solving phase.\ndt: Sets the initial stepsize. Defaults to an automatic choice if the method is adaptive.\ndtmax: Maximum dt for adaptive timestepping.\ndtmin: Minimum dt for adaptive timestepping.\n\nNote that if you want the solution to be output with specifically spaced time steps, you don't want dt, which is just the initial suggestion for adaptive systems; you want to set saveat to the desired spacing.  [The saveat argument could be a vector of specific times at which to save, but because we don't know when the PN evolution ends, this probably isn't useful.]\n\nAlso note that callback can be used, and is combined with the callbacks generated by the termination_criteria_* arguments above.  See the documentation for more details, but note that if you want to make your own callbacks, you will need to add OrdinaryDiffEq to your project — or possibly even DifferentialEquations for some of the fancier built-in callbacks.\n\nInitial frequency vs. first frequency vs. end frequency\n\nNote the distinction between Ωᵢ (with subscript i) and Ω₁ (with subscript 1).  The first, Ωᵢ, represents the angular velocity of the initial condition from which the ODE integrator will begin; the second, Ω₁, represents the target angular velocity of the first element of the output data. That is, the ODE integration will run forwards in time from Ωᵢ to the merger, and then come back to Ωᵢ and run backwards in time to Ω₁.  The output data will stitch these two together to be one continuous (forwards-in-time) data series.\n\nFor example, if you are trying to match to a numerical relativity (NR) simulation, you can read the masses and spins off of the NR data when the system is orbiting at angular velocity Ωᵢ.  Integrating the post-Newtonian (PN) solution forwards in time from this point will allow you to compare the PN and NR waveforms.  However, you may want to know what the waveform was at earlier times than are present in the NR data.  For this, you also have to integrate backwards in time.  We parametrise the point to which you integrate backwards with Ω₁.  In either case, element 1 of the output solution will have frequency Ω₁ — though by default it is equal to Ωᵢ.\n\nSimilarly, the optional argument Ωₑ=1 is the frequency of the end element of the solution — that is Julia's notation for the last element.  Note that this is automatically reduced if necessary so that the corresponding PN parameter v is no greater than 1, which may be the case whenever the total mass is greater than 1.\n\nUp-down instability\n\nBe aware that the up-down instability (where the more massive black hole has spin aligned with the orbital angular velocity, and the less massive has spin anti-aligned) can cause systems with nearly zero precession at the initial time to evolve into a highly precessing system either at earlier or later times.  This is a real physical result, rather than a numerical issue.  If you want to simulate a truly non-precessing system, you should explicitly set the in-place components of spin to precisely 0.  By default, we check for this condition, and will issue a warning if it is likely to be encountered for systems with low initial precession.  The function used to compute the unstable region is up_down_instability.\n\nTime-stepper algorithms\n\nTsit5() is a good default choice for time stepper when using Float64 with medium-low tolerance.  If stiffness seems to be impacting the results, AutoTsit5(Rosenbrock23()) will automatically switch when stiffness occurs. For tighter tolerances, especially when using Double64s, Vern9() or AutoVern9(Rodas5()) are good choices.  For very loose tolerances, as when using Float32s, it might be better to use OwrenZen3().\n\nTermination criteria\n\nThe termination criteria are vital to efficiency of the integration and correctness of the solution.  The default values for forwards- and backwards-in-time evolution, respectively, are\n\nCallbackSet(\n    termination_forwards(v(Ω=Ωₑ, M=M₁+M₂)),\n    dtmin_terminator(T),\n    nonfinite_terminator()\n)\n\nand\n\nCallbackSet(\n    termination_backwards(v(Ω=Ω₁, M=M₁+M₂)),\n    dtmin_terminator(T),\n    nonfinite_terminator()\n)\n\nwhere T is the common float type of the input arguments.  If any additional termination criteria are needed, they could be added as additional elements of the CallbackSets.  See the callback documentation for details.\n\n\n\n\n\n","category":"function"},{"location":"#Computing-mode-weights-from-the-inspiral-data","page":"Home","title":"Computing mode weights from the inspiral data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"h!","category":"page"},{"location":"#PostNewtonian.h!","page":"Home","title":"PostNewtonian.h!","text":"h!(h, u; ℓmin=0)\nh!(h, M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v; ℓmin=0)\nmode_weights!(h, u; ℓmin=0)\nmode_weights!(h, M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v; ℓmin=0)\n\nCompute mode weights of gravitational waves emitted by pn system, modifying h in place.\n\nThese modes are computed in the \"co-orbital\" frame, in which the larger object lies on the positive x axis, the smaller lies on the negative x axis, and the instantaneous angular velocity is in the positive z direction.\n\nThe modes are stored in h in order of increasing ℓ and increasing m, with m iterating fastest, all the way up to the highest available mode, (88).\n\nBecause gravitational waves have spin weight -2, the (ℓm)=(00), (1-1), (10), and (11) modes are always 0.  By default, we assume that these modes are nonetheless included in h.  If that is not the case, set ℓmin to the smallest ℓ value that should be present in the output data — ℓmin=2 being the most reasonable alternative.\n\nAll non-spinning terms are taken from Blanchet (2014).  The 1PN spin-orbit term is from Eq. (3.22d) of Kidder (1995).  The 1.5PN spin-orbit term is from Eq. (3.22f) of Kidder (1995) and Eq. (F15b) of Will and Wiseman (1996).  The 2PN spin-orbit term is from Eq. (4.13) of Buonanno, Faye, Hinderer (2013), while the 2PN spin-spin term is from Eq. (4.15) of that reference.\n\n\n\n\n\n","category":"function"},{"location":"#Detecting-up-down-instability","page":"Home","title":"Detecting up-down instability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"up_down_instability","category":"page"},{"location":"#PostNewtonian.up_down_instability","page":"Home","title":"PostNewtonian.up_down_instability","text":"up_down_instability(u)\nup_down_instability(M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v)\n\nCompute the range of frequencies over which the system is unstable to increasing precession.\n\nThe returned value is a pair of dimensionless frequencies giving the lower and upper frequencies between which we can expect instability.  If there is no instability expected, the returned pair is just (1,1).\n\nFor compact binaries in which the spins are either aligned or anti-aligned with the orbital angular velocity, we do not expect any precession effects — simply by symmetry.  However, if the spin of the higher-mass object is aligned with the orbital angular velocity and the spin of the lower-mass object is anti-aligned, the binary is unstable to precession — meaning that any minuscule misalignment can grow rapidly into significant precession.  This was first reported by Gerosa et al. (2015), and the range over which the system is unstable is given by Eq. (2) of that reference. We use the lowest-order approximation to convert binary separation to frequency.  The result is also \"clamped\" between 0 and 1, because sometimes the PN approximations involved break down and return unphysical values.\n\n\n\n\n\n","category":"function"},{"location":"#Index-of-all-functions","page":"Home","title":"Index of all functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"gwframes/#GWFrames-compatibility-layer","page":"GWFrames","title":"GWFrames compatibility layer","text":"","category":"section"},{"location":"gwframes/","page":"GWFrames","title":"GWFrames","text":"GWFrames is an old python package that was too hard to upgrade to python 3, and therefore became impossible to maintain.  Many of its capabilities have been superseded by the scri and sxs packages, but not the post-Newtonian capabilities.  This package now supersedes the latter.  For convenience, the PostNewtonian.GWFrames submodule provides a simple function to mimic the arguments used with the original GWFrames package to obtain a PN waveform (with a couple extra arguments).  We won't bother to provide a return type that can fully mimic the object returned by the original GWFrames package, though it should be similar to the ones used by scri and sxs.","category":"page"},{"location":"gwframes/","page":"GWFrames","title":"GWFrames","text":"Modules = [PostNewtonian.GWFrames]\nPages   = [\"gwframes.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"gwframes/#PostNewtonian.GWFrames.PNWaveform","page":"GWFrames","title":"PostNewtonian.GWFrames.PNWaveform","text":"PNWaveform(Approximant, delta, chi1_i, chi2_i, Omega_orb_i; kwargs...)\n\nCompute a PN waveform, with the same call signature as GWFrames.PNWaveform\n\nThis is essentially a compatibility layer for the corresponding function in GWFrames, with two additional optional arguments: dt and quiet (see below).  Also, this function accepts optional arguments either as positional arguments (which GWFrames requires) or as keyword arguments.\n\nwarning: Warning\nWe do not expect the result of this function to be identical to the result from GWFrames.  In particular, this package uses more general expressions for the tidal heating terms, fixes an error in the 2PN quadratic-spin terms for the waveform modes, uses a more accurate method to compute the number of steps per orbit (by default), and uses more accurate (and efficient) ODE integration.\n\nThe Julia interface is more detailed, flexible, and efficient than the simple GWFrames interface that this function emulates.  In particular, inspiral takes essentially all the same arguments that DifferentialEquations.solve takes, and returns a solution that provides dense output and more details about the ODE solution itself.  For example, one reason this function is more efficient than GWFrames is that we can use dense output to solve with fewer timesteps, while accurately and efficiently interpolating to the requested timesteps.  While inspiral solves for the dynamics, h! provides the actual mode weights, which are also returned by this function.\n\nRequired arguments\n\nApproximant: Currently, only TaylorT1 is supported.\ndelta: Fractional mass difference (M₁-M₂)(M₁+M₂)\nchi1_i: Normalized spin vector S₁M₁²\nchi2_i: Normalized spin vector S₂M₂²\nOmega_orb_i: Orbital angular frequency at initial instant\n\nOptional arguments\n\nAs mentioned above, the following may be given either as positional arguments in this order (though any number of them may be omitted), or as keyword arguments.\n\nOmega_orb_0=Omega_orb_i: Orbital angular frequency at first instant found in data.  If this is less than Omega_orb_i, the system is integrated backwards in time from the latter value to this value.\nR_frame_i=Rotor(1): Initial orientation of the frame.\nMinStepsPerOrbit=32: Number of time steps in the output data per orbit. Because the waveform modes go as high as m=8, this number should be at least 16 to avoid Nyquist aliasing in those modes.  Note that this value may be overridden by dt (see below).\nPNWaveformModeOrder=3.5: Maximum PN order of terms in the waveform formulas.  Currently, only 3.5 is supported.\nPNOrbitalEvolutionOrder=4.0: Maximum PN order of terms in the orbital-evolution formulas.  Currently, only 4.0 is supported.\ndt=0: Uniform time step size of the output.  If this is not a strictly positive number, MinStepsPerOrbit will be used instead.\nquiet=true: If false, show informational messages about the reasons for terminating the ODE integration.  In either case, warnings will still be issued if terminating for bad or suspicious reasons.  See the documentation of inspiral for an example of how to filter warnings also.\n\nReturned values\n\nThis function returns a NamedTuple with the following keys:\n\nt: The vector of time steps at which the data are evaluated.  The time t=0 corresponds to the initial values that are arguments to this function.\ndata: Matrix of complex values of the mode weights.  The shape is 77 x length(t) x 77.  The first dimension enumerates the values at each instant of time.  The second dimension enumerates the modes, starting with (2-2), then (2-1), up to (22), followed by (3-3), and so on up to (88).  This is the opposite ordering as results from GWFrames, but the same as the ordering used by the sxs and scri packages.  However, also note that certain conversions between Julia and Python may transpose matrices, because Julia is Fortran-ordered by default, whereas numpy is C-ordered.  It is best to check the shape manually to be sure which dimension is which.\nframe: Matrix of shape length(t) x 4 representing the frame-orientation quaternion as a function of time t.\nM1, M2: Vectors of the respective masses as functions of time t. Note that only at the time corresponding to Omega_orb_i will the total mass be precisely 1.  Generally, tidal heating will lead to time-dependent masses.\nchi1, chi2: Matrices of shape length(t) x 3 representing the spins as functions of time t.\nv: PN velocity parameter as a function of time t.\nPhi: Orbital phase as a function of time t.\n\nBecause this is a NamedTuple, the fields can be accessed much like the fields of a WaveformModes object in the scri or sxs python packages — as in w.t and w.data, where w is the object returned by this function.\n\n\n\n\n\n","category":"function"}]
}
